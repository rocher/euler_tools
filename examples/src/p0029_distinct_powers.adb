--  ---------------------------------------------------------------------------
--
--  Copyright (c) 2023 Francesc Rocher <francesc.rocher@gnail.com>
--  SPDX-License-Identifier: MIT
--
--  ---------------------------------------------------------------------------
--   _____ _____           _       _____                           _
--  | ____|_   _|__   ___ | |___  | ____|_  ____ _ _ __ ___  _ __ | | ___  ___
--  |  _|   | |/ _ \ / _ \| / __| |  _| \ \/ / _` | '_ ` _ \| '_ \| |/ _ \/ __|
--  | |___  | | (_) | (_) | \__ \ | |___ >  < (_| | | | | | | |_) | |  __/\__ \
--  |_____| |_|\___/ \___/|_|___/ |_____/_/\_\__,_|_| |_| |_| .__/|_|\___||___/
--                                                          |_|
-- ----------------------------------------------------------------------------
--
--  The following problem is taken from Project Euler:
--
--                 https://projecteuler.net/problem=29
--
--  Distinct powers
--  ---------------
--
--  Consider all integer combinations of a^b for  2 ≤ a ≤ 5  and  2 ≤ b ≤ 5:
--
--                 2^2=4,  2^3=8,   2^4=16,  2^5=32
--                 3^2=9,  3^3=27,  3^4=81,  3^5=243
--                 4^2=16, 4^3=64,  4^4=256, 4^5=1024
--                 5^2=25, 5^3=125, 5^4=625, 5^5=3125
--
--  If they are then placed in numerical order, with any repeats removed, we
--  get the following sequence of 15 distinct terms:
--
--      4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125
--
--  How many distinct terms are in the sequence generated by a^b for
--
--             2 ≤ a ≤ 100  and  2 ≤ b ≤ 100?
--
-------------------------------------------------------------------------------

with Ada.Text_IO;
with Euler_Tools; use Euler_Tools;

procedure P0029_Distinct_Powers is
   use List_Package;
   Answer : Integer_Type := 99**2;  --  all possible combinations
begin
   --  The main idea is to count how many "distinct combinations" of base
   --  and exponent exists within the given ranges. Both 6⁴ and 36² produce
   --  the same result, so in this context they are considered the same
   --  combination.
   --
   --  This counting can be done by considering initially all possible
   --  combinations and discounting combinations with an equivalent one (in
   --  the given ranges). To find an equivalent combination requires
   --  factoring the base an exponent, then applying exponential properties
   --  to increase the base and reduce the exponent. That is, try to
   --  increase the base and reduce the exponent so that:
   --
   --  a^b = p^q  with  2 <= a < p <= 100, 2 <= q <= 100.
   --
   --  If from a^b the equivalent combination p^q can be found, then the
   --  combination a^b must be discounted.
   --
   --  For example:  (note: "⁽²²⁾" denotes a list of factors)
   --
   --     6⁴ = 6⁽²²⁾ = (6²)² = 36²
   --
   --  If all factors of the base are equal, then use that number of
   --  factors (factorized) as a new exponent factor, e.g., 16 factorizes
   --  as (2 2 2 2), which is 2⁴ = 2⁽²²⁾, so
   --
   --    16⁶ = (2⁽²²⁾)⁽²³⁾ = 2⁽²²²³⁾ = 4⁽²²³⁾ = 16⁽²³⁾ = 256³
   --
   --  The new base found is 256 > 100, so 16⁶ has no equivalent
   --  combination with greater base 16 < p <= 100.
   --
   --  The list of factors ⁽²²²³⁾ must be sorted to make sure the new base
   --  is found.
   --
   --  In the case of 27¹⁰⁰:
   --
   --    27¹⁰⁰ = (3 3 3)¹⁰⁰ = (3³)⁽²²⁵⁵⁾ = 3⁽²²³⁵⁵⁾
   --                                    = 9⁽²³⁵⁵⁾
   --                                    = 81⁽³⁵⁵⁾
   --                                    = 81⁷⁵
   --
   --  there is an equivalent combination with a greater base, 81⁷⁵, so
   --  27¹⁰⁰ must be discounted.
   --

   for Base in 2 .. 100 loop
      for Exp in 2 .. 100 loop
         declare
            Base_New : Integer_Type;

            Base_Factors        : constant List_Type := Prime_Factors (Base);
            Base_Factors_Equals : constant Boolean   := Equals (Base_Factors);

            Exp_Factors    : List_Type := Prime_Factors (Exp);
            Factors        : List_Type;
            Length_Factors : Natural;
         begin
            if Base_Factors_Equals then
               for F of Prime_Factors (Length (Base_Factors)) loop
                  Exp_Factors.Append (F);
               end loop;
               Sort (Exp_Factors);
            end if;
            Length_Factors := Length (Exp_Factors);

            Loop_Over_Exponent_Factors :
            for I in 1 .. Length_Factors loop
               if Base_Factors_Equals then
                  Base_New := Base_Factors.First_Element;
               else
                  Base_New := Base;
               end if;

               Factors := Exp_Factors;
               loop
                  begin
                     Base_New := @**Factors.First_Element;
                  exception
                     when Constraint_Error =>
                        Base_New := Integer_Type'Last;
                  end;
                  Factors.Delete_First;
                  exit when Base_New > Base;
               end loop;

               if Base_New <= 100 and then Product (Factors) in 2 .. 100 then
                  --  Duplicate value found
                  Answer := @ - 1;
                  exit Loop_Over_Exponent_Factors;
               end if;

               --  keep trying other exponent factors
               Exp_Factors.Append (Exp_Factors.First_Element);
               Exp_Factors.Delete_First;
            end loop Loop_Over_Exponent_Factors;
         end;
      end loop;
   end loop;

   Ada.Text_IO.Put_Line ("Answer:" & Answer'Image);
end P0029_Distinct_Powers;
